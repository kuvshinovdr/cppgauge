### Пример 009: гипотеза Коллатца

#### Описание

Демонстрация цикла `while`. [Гипотеза](https://ru.wikipedia.org/wiki/%D0%93%D0%B8%D0%BF%D0%BE%D1%82%D0%B5%D0%B7%D0%B0_%D0%9A%D0%BE%D0%BB%D0%BB%D0%B0%D1%82%D1%86%D0%B0) гласит, что какое бы натуральное число вы не взяли в качестве начального, рано или поздно при применении преобразования (см. в коде или по ссылке) получится единица.

#### Код

```cpp
#include <iostream>

int main()
{
    using namespace std;
    cout << "Collatz sequence, enter natural numbers.\n";

    for (unsigned long long n; cin >> n;) {
        while (n > 1) {
            cout << n << " -> ";
            n = n & 1? 3 * n + 1: n / 2;
        }

        cout << n << "\nSequence finished.\n";
    }

    return 0;
}
```

#### Построчный разбор

Тип `unsigned long long` является целочисленным беззнаковым шириной не менее 64 бит. Организуем с помощью него **цикл ввода** натуральных чисел:

```cpp
for (unsigned long long n; cin >> n;) {
```

Вложенный **цикл с предусловием** (`while`) будет выполняться, пока условие не станет ложным:

```cpp
while (n > 1) {
```

Цикл while эквивалентен циклу for с пустыми первой и третьей секциями:

```cpp
for (;n > 1;) {
```

Тернарный оператор (`?:`) позволяет занести условие внутрь выражения:

```cpp
n = n & 1? 3 * n + 1: n / 2;
```

Здесь условием является выражение `n & 1`. Если оно вычислится как 0, то будет считаться ложным, и значением станет выражение после `:` (т.е. `n / 2`). Иначе оно будет считаться истинным, и значением станет выражение между `?` и `:` (т.е. `3 * n + 1`). Операция `&` есть побитовое *и*, таким образом, `n & 1` означает *извлечь младший бит* `n` и эквивалентно взятию остатка (без знака) от деления на 2.
